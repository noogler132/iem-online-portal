'use strict';
var Promise = require('bluebird');

var copyProperties = require('authbox-common/copyProperties');
var emptyFunction = require('authbox-common/emptyFunction');
var invariant = require('authbox-common/invariant');
var merge = require('authbox-common/merge');
var request = require('request');

function getRequestData(req) {
  return Promise.props({
    default: Promise.promisify(Client.config.getDefaultRequestData)(req),
    user: Promise.promisify(Client.config.getRequestData)(req)
  }).then(function(allRequestData) {
    return merge(allRequestData.default, allRequestData.user);
  });
}

function getAuthboxData(req) {
  req._authbox = req._authbox || {};
  req._authbox.fired = req._authbox.fired || {
    check: false,
    log: false
  };
  req._authbox.checkedAction = req._authbox.checkedAction || null;
  req._authbox.checkedVerdictType = req._authbox.checkedVerdictType || null;

  return req._authbox;
}

var Client = {
  config: {
    apiKey: null,
    secretKey: null,
    enableTrackingPixel: true,
    rollout: 1.0,
    getRequestData: function(req, cb) {
      cb(null, {});
    },
    getDefaultRequestData: function(req, cb) {
      cb(null, {});
    },
    endpoint: 'https://api.authbox.io/api',
    timeout: 700
  },

  logDefaultAction: function(request) {
    var authboxData = getAuthboxData(request);

    if (authboxData.fired.log) {
      return;
    }

    Client._log(request, authboxData.checkedAction);
  },

  configure: function(configUpdates) {
    copyProperties(Client.config, configUpdates);
  },

  _ensureOneRequest: function(type, request, cb) {
    var authboxData = getAuthboxData(request);

    invariant(authboxData.fired.hasOwnProperty(type), 'Bad type name: %s', type);

    if (authboxData.fired[type]) {
      var message = 'You can only fire 1 %s per HTTP request';
      console.warn('AUTHBOX: ' + message, type);
      if (cb) {
        cb(message, null);
      }
      return true;
    }
    authboxData.fired[type] = true;
    return false;
  },

  check: function(request, action, cb) {
    if (Client._ensureOneRequest('check', request, cb)) {
      return;
    }

    var authboxData = getAuthboxData(request);
    authboxData.checkedAction = action;

    Client._fire('/action_check', request, action, function(verdict) {
      authboxData.checkedVerdictType = verdict.type;
      return cb.apply(this, arguments);
    });
  },

  log: function(request, action) {
    if (Client._ensureOneRequest('log', request)) {
      return;
    }

    Client._log(request, action);
  },

  _log: function(request, action) {
    var authboxData = getAuthboxData(request);

    if (authboxData.fired.check && authboxData.checkedVerdictType !== 'ALLOW') {
      return;
    }

    Client._fire('/action_log', request, action);
  },

  _fire: function(endpoint, req, action, cb) {
    action = action || {};
    cb = cb || emptyFunction;

    getRequestData(req).then(function(requestData) {
      invariant(
        Client.config.apiKey,
        'No apiKey configured. Did you forget to call authbox.configure()?'
      );

      invariant(
        Client.config.secretKey,
        'No secretKey configured. Did you forget to call authbox.configure()?'
      );

      var actionData = merge({
        $timestamp: Date.now(),
        $apiKey: Client.config.apiKey,
        $secretKey: Client.config.secretKey,
      }, requestData, action);

      request.post({
        uri: Client.config.endpoint + endpoint,
        headers: {'content-type': 'application/json'},
        body: JSON.stringify(actionData),
        timeout: Client.config.timeout
      }, function(err, res, body) {
        if (err) {
          // fail open
          cb({type: 'ALLOW', info: 'Server request failed: ' + err.toString()});
          return;
        }

        var parsedResponse;
        try {
          parsedResponse = JSON.parse(body);
          invariant(typeof parsedResponse.type === 'string', 'verdict did not include a type key: ' + body + ' ' + Client.config.endpoint + endpoint);
        } catch (e) {
          // fail open
          cb({type: 'ALLOW', info: 'Bad response from server: ' + e.toString()});
          return;
        }

        cb(parsedResponse);
      });
    });
  }
};

module.exports = Client;
